# -*- coding: utf-8 -*-
"""Different_data_types_sup2_SiyaoXue

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qzPHVgmXRJ3dissail2anHJARNgoAMSr
"""

#please run this cell first to import
import numpy as np
import pandas as pd
from google.colab import drive

#Question 1
#array that contains the values
contained = np.array([5, 15, 25])
contained_reshaped = contained.reshape((1, 3))
#twice a row
array_row = np.hstack((contained_reshaped,contained_reshaped))
#five rows
array_final = np.vstack([array_row]*5)

print(array_final)

#Question 2
#using loop
#9x9 array of zeros
array = np.zeros((9, 9))
#use loops to enter values of 1
for i in range(9):
  for j in range(9):
    if i == 0 or i == 8 or j == 0 or j == 8:
      array[i, j] = 1
    elif i in [1, 7] or j in [1, 7]:
      array[i, j] = 0
    elif i in [2, 6] or j in [2, 6] or (i == 4 and j == 4):
      array[i, j] = 1
print("Using loop:")
print(array)

#using "pad" functions
#innermost 3x3 array
array = np.array([[0, 0, 0],
          [0, 1, 0],
          [0, 0, 0]],dtype=float)
#pad the array with 1s
array = np.pad(array, pad_width=1, constant_values=1)
#pad the array with 0s
array = np.pad(array, pad_width=1, constant_values=0)
#pad the array with 1s
array = np.pad(array, pad_width=1, constant_values=1)

print("Using pad function:")
print(array)

#Queestion 3
#pieces that will be used
chess_pieces = ['R', 'H', 'B', 'Q', 'K', 'B', 'H', 'R']
pawn = ['P']*8
unoccupied = [' ']*8

#numpy array for the chessboard
chessboard = np.array([chess_pieces, pawn, unoccupied, unoccupied, unoccupied, unoccupied, pawn, chess_pieces])

print(chessboard)

#Question 4
#array of numbers from 1 to 100
numbers = np.arange(1, 101)

#set the first element to zero
numbers[0] = 0

#Sieve of Eratosthenes
for prime in [2, 3, 5, 7]:
  numbers[prime*2-1::prime] = 0

#filter out the zeros
prime_numbers = numbers[numbers != 0]

print(prime_numbers)

#Question 5
# Given lists
incomes = [40000, 35000, 45000, 300000, 90000, 400000, 115000, 25000, 80000]
heights = [60.5, 59.6, None, 73.4, 65.9, 72.4, None, 66.8, None]
#DataFrame
df = pd.DataFrame({
    'Income': incomes,
    'Height': heights
})

#reset income values above 150000 to 150000
df['Income'] = df['Income'].apply(lambda x: min(x, 150000))

#set missing height malues to the mean of non-missing values
df['Height'].fillna(df['Height'].mean(), inplace=True)

print(df)

#Questiion 6
#mount Google Drive
drive.mount('/content/drive')

#read the CSV file
file_path_numb = '/content/drive/My Drive/Colab Notebooks/numbers.csv'
df_numb = pd.read_csv(file_path_numb)
print(df_numb)

#add a median column
df_numb['median'] = df_numb.median(axis=1)
#get the max
max_median = df_numb['median'].max()
max_median_index = df_numb['median'].idxmax()
#get the median of median column
median_of_medians = df_numb['median'].median()
#get the median of all
median_of_all_values = df_numb.stack().median()
#print
print("Maximum median: ",max_median)
print("Maximum median index: ",max_median_index)
print("Median of median columns: ",median_of_medians)
print("Median of all values: ",median_of_all_values)
print(f"Are these medians the same? {'Yes' if median_of_medians == median_of_all_values else 'No'}")

#Question 7
#mount Google Drive
drive.mount('/content/drive')

#read the CSV file
file_path_meal = '/content/drive/My Drive/Colab Notebooks/meals.csv'
df_meal = pd.read_csv(file_path_meal)
print(df_meal)

#fin maximum price for each cuisine type
max_prices = df_meal.groupby('cuisine')['price'].max()

#sort in descending order and select the top 5
top_cuisines = max_prices.sort_values(ascending=False).head(5)

print(top_cuisines)

#Question 8
#removing the dollar sign
df_meal['price'] = pd.to_numeric(df_meal['price'].str.replace('$', ''), errors='coerce')

#group by cuisine and calculate desired metrics
cuisine_summary = df_meal.groupby('cuisine')['price'].agg(
    num_meals = 'count',
    avg_price = 'mean',
    min_pric = 'min',
    max_price = 'max',
    price_std = 'std'
)

#sort by average price in ascending order
summary_sorted = cuisine_summary.sort_values(by='avg_price')

print(summary_sorted)

#Question 9
ownership = pd.DataFrame(
    {
     "name": ["Sam","Eric","Audrey","Isabel","Anika","Nathan","Catherine",
              "Chris","Julie","Stephen","John","Jim","Mary"],
     "cars": [
         ["Ford","Toyota","Volkswagen","Nissan","Hyundai"],
         ["Toyota","Chevrolet","Nissan","Jaguar","Volkswagen","General Motors"],
         ["Jeep","Ford","Chrysler","Fiat","General Motors","Volkswagen"],
         ["Rolls Royce","Bentley","Porsche","BMW"],
         ["Toyota", "Chevrolet", "Hyundai","Fiat"],
         ["Trabant", "Skoda", "Mercedes","Honda","General Motors"],
         ["Renault", "Geely", "Volvo","Skoda","Suzuki","Honda"],
         ["Ford","Toyota","Tata","Suzuki","Mercedes"],
         ["Fiat", "Rolls Royce", "Tata","BMW"],
         ["Chrysler", "Jaguar", "Volvo","Fiat"],
         ["Geely", "Jeep", "Fiat"],
         ["Chevrolet", "Volvo", "Fiat","Geely","Ford"],
         ["Toyota", "Fiat", "Chrysler","Bentley","Porsche","Renault"],
     ],
    }
)
#explode the 'cars' given a pd with cars and owners
ownership_exp = ownership.explode('cars')

#manufacturer appears the most
most__manufacturer = ownership_exp['cars'].value_counts().idxmax()

#manufacturer appears the least
least_manufacturer = ownership_exp['cars'].value_counts().idxmin()

#person who owned the fewest cars
fewest_cars_person = ownership['name'][ownership['cars'].str.len().idxmin()]

print(f"Manufacturer appears the most often: {most__manufacturer}")
print(f"Manufacturer appears the least often: {least_manufacturer}")
print(f"Person who owned the fewest cars: {fewest_cars_person}")

#Question 10
#mount Google Drive
drive.mount('/content/drive')

#read the CSV file
file_path_sp = '/content/drive/My Drive/Colab Notebooks/stock_prices.csv'
df_sp = pd.read_csv(file_path_sp)
print(df_sp)

#calculate the spread between high and low prices
df_sp['spread'] = df_sp['high'] - df_sp['low']
#sort the dataframe
df_sp.sort_values(by=['ticker','spread'], inplace=True)

print(df_sp)