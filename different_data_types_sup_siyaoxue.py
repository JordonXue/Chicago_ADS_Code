# -*- coding: utf-8 -*-
"""Different_data_types_sup_SiyaoXue

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T4AiNqdR1GJsooKY-Cvc0wQf8CR9m3JE
"""

#Question 1 - get prime factors of n
def prime_factors(n):
  #used to store prime factors
  factor = []
  #exclude 0
  while (n%2 == 0) and (n != 0):
    factor.append(2)
    n = n//2
  #check prime
  i = 3
  while i * i <= n:
    while n % i == 0:
      factor.append(i)
      n //= i
    i += 2
  if n > 2:
    factor.append(n)

  return factor
print(prime_factors(1))
print(prime_factors(7))
print(prime_factors(36))
print(prime_factors(27))
print(prime_factors(100))

#Question 2 - recursive get primae factor of n
def prime_factors_r(n, div=2):
  if n <= 1:
    #base case
    return []
  if n % div == 0:
    #recursion
    return [div] + prime_factors_r(n // div, div)
  else:
    #recursion
    return prime_factors_r(n, div + 1)
print(prime_factors(1))
print(prime_factors(7))
print(prime_factors(36))
print(prime_factors(27))
print(prime_factors(100))

#Question 3
def venn(m,n):
  #sets for prime factors of m and n
  factor_m, factor_n = set(), set()
  temp_m, temp_n = m, n
  #find prime factors for m
  i = 2
  while i*i <= temp_m:
    while temp_m % i == 0:
      factor_m.add(i)
      temp_m //= i
    i += 1
  if temp_m > 1:
    factor_m.add(temp_m)
  #find prime factors for n
  i = 2
  while i*i <= temp_n:
    while temp_n % i == 0:
      factor_n.add(i)
      temp_n //= i
    i += 1
  if temp_n > 1:
    factor_n.add(temp_n)
  #get common prime factors, m only and n only
  m_only = factor_m - factor_n
  n_only = factor_n - factor_m
  mncommon = factor_m & factor_n

  return m_only, n_only, mncommon
print(venn(23,46))
print(venn(35,7))
print(venn(2,3))

#Question 4
#determine if two number have the same set of prime factors
def same_prime_determine(m,n):
  #use to venn function defined in last question
  m_only, n_only, mncommon = venn(m,n)
  if (mncommon != set()):
    return mncommon
  else:
    return "There's no common prime factor."
print(same_prime_determine(40,100))
print(same_prime_determine(10,18))
print(same_prime_determine(2,3))

#Question 5
#calculate the sum of all factors
sumFactors = lambda n: sum(i for i in range(1, n) if n % i == 0)
#print out perfect number under 10000, where sum of all factors equal
print([x for x in range(1,10000) if sumFactors(x) == x])

#Question 6
#get the prime within given limit l and u
prime_number = lambda l, u: len(list(filter(lambda x: all(x % i != 0 for i in range(2, int(x ** 0.5) + 1)) and x > 1, range(l, u+1))))
print(prime_number(1,10))
print(prime_number(1,100))
print(prime_number(11,100))

#Question 7
#find integer Unicode point value
letter_num = lambda c: ord(c) - ord('a') + 1
#return a list of value in a string
letter_nums = lambda s: [letter_num(c) for c in s]
print(letter_num("a"))
print(letter_num("z"))
print(letter_nums("sound"))

#Question 8
# Add rotate value to the ascii value of a character, %26 since only 26 letter and will go back to the beginning if result > 26
rotate = lambda c, n: chr(((ord(c) - 97 + n) % 26) + 97)
print(rotate("z", 2))
print(rotate("b", 3))
print(rotate("f", 1))

#Question 9
def encrypt(a,b):
  encrypted = ""
  #get the same length
  new_b = (b * (len(a) // len(b) + 1))[:len(a)]
  #shift the word and encrypt it
  for i in range(len(a)):
    shift = ord(new_b[i]) - ord("a") + 1
    new_ord = ord(a[i]) + shift
    if new_ord > ord("z"):
      new_ord -= 26
    encrypted += chr(new_ord)
  return encrypted
print(encrypt("zebra","ab"))
print(encrypt("hello","a"))

#Question 10
def square(x):
  #undecorated
  return x * x
square(5)
#square("i")

def trapError(f):
    return lambda x: None if isinstance(x, str) else f(x)
#decorated
@trapError
def square(x):
  return x * x
print(square(5))
print(square(5.5))
print(square("Hi"))

#Question 11
car = "ðŸšƒ"
#get the code point
code_point = ord(car)
print(f'code point for {car} is: {code_point}')
#binary version of the code point
format_as_padded_bin = '021b'
padded_bin = f'{code_point:{format_as_padded_bin}}'
print(f'{code_point} is in binary is: {padded_bin}')
#distribute into 4 bytes
a, b, c, d = padded_bin[:3], padded_bin[3:9], padded_bin[9:15], padded_bin[15:]
encoded = f'11110{a}10{b}10{c}10{d}'
print(f'encoded as utf-8, in binary: {encoded}')
#turn into a sequence of bytes, with each byte shown in binary (as a string)
bytes_as_bin = list(encoded[i: i + 8] for i in range(0, 25, 8))
print(f'bytes as strings in a list: {bytes_as_bin}')
#convert each string into an int, and use that to create a bytes object b
b = bytes([int(i, 2) for i in bytes_as_bin])
print(b)
#call decode on bytes object to get back character
print('original character:', b.decode("utf-8"))